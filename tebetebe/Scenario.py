#!/usr/bin/env python3

import subprocess
import logging
import shutil
import osrm
import time
import sys
import sh

from contextlib import AbstractContextManager
from sh import CommandNotFound
from functools import partial
from pathlib import Path

from .RoutingProfile import RoutingProfile
from .RouteNetwork import RouteNetwork
from .OSRM import OSRM
from . import defaults
from . import utils

class Scenario():
    """
    Scenario is an abstraction of the OSRM binaries in order to dissolve a
    route network and routing profile into a routable OSRM file

    Parameters
    ----------
    route_network : str / RouteNetwork
        Route network to be used in scenario
    routing_profile : str / RoutingProfile
        Routing profile to be used in scenario
    name : str, optional
        Scenario name used in output file and log entries. If not supplied, it will be built based upon the route network & routing profile names
    algorithm : str
        Algorithm to be used (either "CH" or "MLD")
    tmp_dir : str
        Temporary directory to store files generated by osrm binaries
    overwrite: bool
        Overwrite scenario if .osrm* files already exist. Otherwise, the existing .osrm* files will be used.
    verbose: bool
        Print output of OSRM compilation
    """

    def __init__(self, route_network, routing_profile,
                 name=None, algorithm="MLD", 
                 tmp_dir=defaults.TMP_DIR,
                 overwrite=defaults.OVERWRITE,
                 verbose=defaults.VERBOSE,
                 **kwargs):

        self.log = logging.getLogger(defaults.LOGGER)
        self.algorithm = algorithm.upper()
        self.tmp_dir = Path(tmp_dir)
        self.overwrite = overwrite

        ## Handle if params are passed as string
        if isinstance(route_network, str):
            route_network = RouteNetwork(route_network, tmp_dir=self.tmp_dir)

        if isinstance(routing_profile, str):
            routing_profile = RoutingProfile(routing_profile)

        self.route_network = route_network
        self.routing_profile = routing_profile

        ## Initialize / check OSRM Binaries
        self.OSRM = OSRM(verbose=verbose)

        ## Scenario name and output osrm path
        self.name = name if name else "{}_{}".format(self.route_network.get_name(),
                                                     self.routing_profile.get_name())
        self.path = self.tmp_dir / self.name / "{}.osrm".format(self.name)
        self.path.parent.mkdir(parents=True, exist_ok=True) # Make sure output_dir exists

    def get_name(self):
        """Return the Scenario name"""
        return self.name

    def get_path(self):
        """Return the Scenario Path"""
        return self.path

    def compile(self, extract_args = {}, contract_args = {},
                partition_args = {}, customize_args = {}):
        '''
        
        Compile route network and routing profile into a routable OSRM file

        Parameters
        ----------
        extract_args: dict, optional
            Any additional arguments to pass to osrm-extract
        contract_args: dict, optional
            Any additional arguments to pass to osrm-contract (algorithm="CH" only)
        partition_args: dict, optional
            Any additional arguments to pass to osrm-partition (algorithm="MLD" only)
        customize_args: dict, optional
            Any additional arguments to pass to osrm-customize (algorithm="MLD" only)
        '''

        ## Honor overwrite settings
        if self.path.is_file():
            if self.overwrite:
                self.log.info("{}: Overwriting scenario".format(self.name))

                ## Remove all .osrm* files
                for osrm_file in self.path.parent.glob("{}.osrm*".format(self.name)):
                    osrm_file.unlink()
            else:
                self.log.info("{}: Using existing scenario".format(self.name))
                return

        try:
            self.log.info("{}: Compiling scenario ({})".format(self.name, self.algorithm))

            ## Run osrm-extract
            extr = self.OSRM.extract(self.route_network.get_path(),
                                     self.routing_profile.get_path(),
                                     **extract_args)
            extr.wait() ## synchronous execution

            ## osrm-extract generates osrm file in same folder as route_network
            ## so rename and move all files to self.path
            network_path = self.route_network.get_path()

            for src_path in network_path.parent.glob("{}.osrm*".format(network_path.stem.split(".")[0])):
                dst_file = src_path.name.replace(src_path.stem.split(".")[0], self.name)
                dst_path = self.path.parent / dst_file

                shutil.move(src_path, dst_path)

            ## Run different binaries depending on algorithm used
            if self.algorithm == "MLD":
                part = self.OSRM.partition(self.path, **partition_args)
                part.wait()

                cust = self.OSRM.customize(self.path, **customize_args)
                cust.wait()

            elif self.algorithm == "CH":
              cont = self.OSRM.contract(self.path, **contract_args)
              cont.wait()

        except Exception as exc:
            ## TODO custom handle more common exception
            self.log.error(exc)

    def run(self, **kwargs):
        '''Compile and run scenario, and return ScenarioAPI. Any `**kwargs` are passed as arguments to osrm-routed. This can also be called by Scenario(**kwargs)'''

        ## Compile scenario
        try:
            self.compile()
            return ScenarioAPI(self, call_opts={**kwargs})
        except Exception as exc:
            self.log.error(exc)

    ## Alias for calling
    __call__ = run

class ScenarioAPI(AbstractContextManager):
    '''
    ScenarioAPI is a context manager for the execution of the `osrm-routed` HTTP server,
    and provides a low-level API for querying that server

    The low-level API (`match`, `nearest`, `simple_route`, `table`, `trip`) is provided by the `python-osrm` module (https://github.com/ustroetz/python-osrm)

    Parameters
    ----------
    scenario : Scenario
        Scenario for which the API is to query
    call_opts : dict
        Any additional parameters to be passed to osrm-routed
    '''

    ## These are here so sphinx pulls the API documentation from python-osrm
    simple_route = osrm.simple_route
    nearest = osrm.nearest
    match = osrm.match
    table = osrm.table
    trip = osrm.trip

    def __init__(self, scenario, call_opts={}, **kwargs):
        super(ScenarioAPI, self).__init__()

        self.log = logging.getLogger(defaults.LOGGER)
        self.scenario = scenario
        self.call_opts = call_opts

    def is_alive(self):
        """True if Scenario process is running, False otherwise"""
        if hasattr(self, "process") and hasattr(self.process, "process"):
            return self.process.process.is_alive()
        else:
            return False

    def _set_config(self, port):
        self.config = osrm.RequestConfig("127.0.0.1:{}/v1/skobuffs".format(port))

        self.simple_route = partial(osrm.simple_route, url_config=self.config)
        self.nearest = partial(osrm.nearest, url_config=self.config)
        self.match = partial(osrm.match, url_config=self.config)
        self.table = partial(osrm.table, url_config=self.config)
        self.trip = partial(osrm.trip, url_config=self.config)

    def __enter__(self):
        self.call_opts["port"] = utils.find_open_port()
        self.call_opts["algorithm"] = self.scenario.algorithm
        self.call_opts["dataset_name"] = self.scenario.name

        ## Point the osrm http api to correct port
        self._set_config(self.call_opts["port"])
        self.ready = False

        ## Start up OSRM Server
        try:
            ## Callback to execute when OSRM process is ready to receive http requests
            def ready_callback(process):
                self.ready = True

            ## Callback when command exits
            def done_callback(cmd, success, exit_code):
                ## -9 = SIGKILL = it was (probably) killed by this script. aka, this is normal.
                if exit_code != -9:
                    self.log.error("{}: Scenario process exited with exit code {}".format(self.scenario.name, exit_code))
                    self.log.error("{}: Command: {}".format(self.scenario.name, cmd))


            self.log.info("{}: Initializing scenario".format(self.scenario.name))
            self.process = self.scenario.OSRM.routed(self.scenario.path,
                                                     ready_callback,
                                                     done_callback,
                                                     **self.call_opts)

        except Exception as exc:
            self.log.error(exc)

        ## Wait until OSRM-routed is ready before returning the api
        ## TODO better way to do this
        while not self.ready:
            time.sleep(1)

        self.log.info("{}: Ready for requests".format(self.scenario.name))

        return self

    def __exit__(self, exc_type, exc_value, traceback):
        ## TODO handle common exceptions
        if exc_type:
            self.log.error("{} {} {}".format(exc_type, exc_value, traceback))

        ## Kill the OSRM process
        try:
            self.process.kill()
        except:
            pass
